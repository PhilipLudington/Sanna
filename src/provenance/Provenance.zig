//! Provenance and Confidence Types
//!
//! This module defines the core data structures for tracking code authorship,
//! AI confidence levels, review status, and generation metadata.
//!
//! ## Provenance Tracking
//!
//! Provenance metadata captures who authored code (human or AI), confidence
//! levels, review status, and generation checkpoints for AI-assisted development.
//!
//! ## Usage
//!
//! ```sanna
//! @author(human, identity = "alice@example.com")
//! @confidence(0.95)
//! @approved(by = "bob@example.com", at = "2024-01-15T10:30:00Z")
//! spec fn add(a: i32, b: i32) -> i32
//! ```

const std = @import("std");
const Allocator = std.mem.Allocator;
const Span = @import("../lexer/root.zig").Span;

// ============================================================================
// Author Types
// ============================================================================

/// The source/author of code
pub const AuthorKind = enum {
    /// Written by a human
    human,
    /// Generated by AI
    ai,
    /// Mixed human and AI authorship
    mixed,
    /// Unknown or unspecified authorship
    unknown,

    pub fn fromString(s: []const u8) ?AuthorKind {
        const map = std.StaticStringMap(AuthorKind).initComptime(.{
            .{ "human", .human },
            .{ "ai", .ai },
            .{ "mixed", .mixed },
            .{ "unknown", .unknown },
        });
        return map.get(s);
    }

    pub fn toString(self: AuthorKind) []const u8 {
        return switch (self) {
            .human => "human",
            .ai => "ai",
            .mixed => "mixed",
            .unknown => "unknown",
        };
    }
};

/// Information about code authorship
pub const Author = struct {
    /// Kind of author (human, AI, etc.)
    kind: AuthorKind,
    /// Human identity (email, username, etc.)
    identity: ?[]const u8 = null,
    /// AI model name (e.g., "opus-4.5")
    model: ?[]const u8 = null,
    /// Hash of the prompt used for generation
    prompt_hash: ?[]const u8 = null,
    /// Human reviewer who reviewed AI-generated code
    reviewed_by: ?[]const u8 = null,
    /// Source span of the @author attribute
    span: ?Span = null,

    pub fn human(identity: ?[]const u8) Author {
        return .{ .kind = .human, .identity = identity };
    }

    pub fn ai(model: ?[]const u8) Author {
        return .{ .kind = .ai, .model = model };
    }
};

// ============================================================================
// Confidence
// ============================================================================

/// AI confidence level (0.0 to 1.0)
pub const Confidence = struct {
    /// Confidence value between 0.0 and 1.0
    value: f64,
    /// Source span of the @confidence attribute
    span: ?Span = null,

    pub const min_value: f64 = 0.0;
    pub const max_value: f64 = 1.0;

    /// Confidence thresholds
    pub const Threshold = struct {
        pub const high: f64 = 0.9;
        pub const medium: f64 = 0.7;
        pub const low: f64 = 0.5;
    };

    /// Create a confidence value, clamping to valid range
    pub fn init(value: f64) Confidence {
        return .{
            .value = std.math.clamp(value, min_value, max_value),
        };
    }

    /// Check if confidence is within valid range
    pub fn isValid(value: f64) bool {
        return value >= min_value and value <= max_value;
    }

    /// Get confidence level category
    pub fn level(self: Confidence) Level {
        if (self.value >= Threshold.high) return .high;
        if (self.value >= Threshold.medium) return .medium;
        if (self.value >= Threshold.low) return .low;
        return .very_low;
    }

    pub const Level = enum {
        high,
        medium,
        low,
        very_low,

        pub fn toString(self: Level) []const u8 {
            return switch (self) {
                .high => "high",
                .medium => "medium",
                .low => "low",
                .very_low => "very_low",
            };
        }
    };
};

// ============================================================================
// Review Status
// ============================================================================

/// Request for code review
pub const NeedsReview = struct {
    /// Reason why review is needed
    reason: ?[]const u8 = null,
    /// Priority level
    priority: Priority = .normal,
    /// Source span
    span: ?Span = null,

    pub const Priority = enum {
        low,
        normal,
        high,
        critical,

        pub fn fromString(s: []const u8) ?Priority {
            const map = std.StaticStringMap(Priority).initComptime(.{
                .{ "low", .low },
                .{ "normal", .normal },
                .{ "high", .high },
                .{ "critical", .critical },
            });
            return map.get(s);
        }
    };
};

/// Approval record
pub const Approval = struct {
    /// Who approved (email, username)
    by: []const u8,
    /// When approved (ISO 8601 timestamp)
    at: ?[]const u8 = null,
    /// Optional note about approval
    note: ?[]const u8 = null,
    /// Source span
    span: ?Span = null,
};

// ============================================================================
// Verification Status Metadata
// ============================================================================

/// Verification status from @verified attribute
pub const VerifiedStatus = enum {
    /// Successfully verified
    proven,
    /// Not yet proven
    unproven,
    /// Verification in progress
    pending,
    /// Assumed true (admitted)
    admitted,

    pub fn fromString(s: []const u8) ?VerifiedStatus {
        const map = std.StaticStringMap(VerifiedStatus).initComptime(.{
            .{ "proven", .proven },
            .{ "unproven", .unproven },
            .{ "pending", .pending },
            .{ "admitted", .admitted },
        });
        return map.get(s);
    }

    pub fn toString(self: VerifiedStatus) []const u8 {
        return switch (self) {
            .proven => "proven",
            .unproven => "unproven",
            .pending => "pending",
            .admitted => "admitted",
        };
    }
};

/// Verification attribute metadata
pub const VerificationInfo = struct {
    /// Verification status
    status: VerifiedStatus,
    /// List of unproven obligations
    obligations: []const []const u8 = &.{},
    /// Source span
    span: ?Span = null,
};

// ============================================================================
// Generation Tracking
// ============================================================================

/// Checkpoint for resumable AI generation
pub const GenerationCheckpoint = struct {
    /// AI model used
    model: []const u8,
    /// Timestamp of checkpoint (ISO 8601)
    timestamp: ?[]const u8 = null,
    /// Hash of the context/prompt
    context_hash: ?[]const u8 = null,
    /// Version of the generation
    version: ?u32 = null,
    /// Source span
    span: ?Span = null,
};

/// Marker for in-progress generation
pub const GeneratingMarker = struct {
    /// AI model performing generation
    model: ?[]const u8 = null,
    /// When generation started (ISO 8601)
    started_at: ?[]const u8 = null,
    /// Source span
    span: ?Span = null,
};

// ============================================================================
// Provenance Metadata
// ============================================================================

/// Complete provenance metadata for a specification or declaration
pub const ProvenanceMetadata = struct {
    allocator: Allocator,

    /// Authors (may have multiple for mixed authorship)
    authors: std.ArrayListUnmanaged(Author),
    /// AI confidence level
    confidence: ?Confidence = null,
    /// Review request
    needs_review: ?NeedsReview = null,
    /// Approvals (may have multiple)
    approvals: std.ArrayListUnmanaged(Approval),
    /// Verification info
    verification: ?VerificationInfo = null,
    /// Generation checkpoint
    checkpoint: ?GenerationCheckpoint = null,
    /// Currently generating marker
    generating: ?GeneratingMarker = null,
    /// Associated spec/declaration name
    name: ?[]const u8 = null,

    pub fn init(allocator: Allocator) ProvenanceMetadata {
        return .{
            .allocator = allocator,
            .authors = .{},
            .approvals = .{},
        };
    }

    pub fn deinit(self: *ProvenanceMetadata) void {
        // Free authors
        for (self.authors.items) |*author| {
            if (author.identity) |id| self.allocator.free(id);
            if (author.model) |m| self.allocator.free(m);
            if (author.prompt_hash) |ph| self.allocator.free(ph);
            if (author.reviewed_by) |rb| self.allocator.free(rb);
        }
        self.authors.deinit(self.allocator);

        // Free approvals
        for (self.approvals.items) |*approval| {
            self.allocator.free(approval.by);
            if (approval.at) |at| self.allocator.free(at);
            if (approval.note) |n| self.allocator.free(n);
        }
        self.approvals.deinit(self.allocator);

        // Free needs_review
        if (self.needs_review) |*nr| {
            if (nr.reason) |r| self.allocator.free(r);
        }

        // Free verification info
        if (self.verification) |*v| {
            for (v.obligations) |ob| {
                self.allocator.free(ob);
            }
            if (v.obligations.len > 0) {
                self.allocator.free(v.obligations);
            }
        }

        // Free checkpoint
        if (self.checkpoint) |*cp| {
            self.allocator.free(cp.model);
            if (cp.timestamp) |ts| self.allocator.free(ts);
            if (cp.context_hash) |ch| self.allocator.free(ch);
        }

        // Free generating marker
        if (self.generating) |*g| {
            if (g.model) |m| self.allocator.free(m);
            if (g.started_at) |sa| self.allocator.free(sa);
        }

        // Free name
        if (self.name) |n| self.allocator.free(n);
    }

    /// Add an author
    pub fn addAuthor(self: *ProvenanceMetadata, author: Author) !void {
        try self.authors.append(self.allocator, author);
    }

    /// Add an approval
    pub fn addApproval(self: *ProvenanceMetadata, approval: Approval) !void {
        try self.approvals.append(self.allocator, approval);
    }

    /// Check if code is human-authored
    pub fn isHumanAuthored(self: *const ProvenanceMetadata) bool {
        if (self.authors.items.len == 0) return false;
        for (self.authors.items) |author| {
            if (author.kind == .human) return true;
        }
        return false;
    }

    /// Check if code is AI-generated
    pub fn isAiGenerated(self: *const ProvenanceMetadata) bool {
        if (self.authors.items.len == 0) return false;
        for (self.authors.items) |author| {
            if (author.kind == .ai) return true;
        }
        return false;
    }

    /// Check if code has been approved
    pub fn isApproved(self: *const ProvenanceMetadata) bool {
        return self.approvals.items.len > 0;
    }

    /// Check if code needs review
    pub fn needsReview(self: *const ProvenanceMetadata) bool {
        return self.needs_review != null;
    }

    /// Get primary author (first author if multiple)
    pub fn primaryAuthor(self: *const ProvenanceMetadata) ?*const Author {
        if (self.authors.items.len == 0) return null;
        return &self.authors.items[0];
    }

    /// Get confidence level, or null if not set
    pub fn getConfidenceLevel(self: *const ProvenanceMetadata) ?Confidence.Level {
        if (self.confidence) |c| {
            return c.level();
        }
        return null;
    }
};

// ============================================================================
// JSON Serialization
// ============================================================================

/// Serialize provenance metadata to JSON
pub fn toJson(allocator: Allocator, metadata: *const ProvenanceMetadata) ![]u8 {
    var buf = std.ArrayListUnmanaged(u8){};
    errdefer buf.deinit(allocator);

    try buf.appendSlice(allocator, "{");

    var first = true;

    // Name
    if (metadata.name) |name| {
        try appendJsonField(&buf, allocator, "name", name, &first);
    }

    // Authors
    if (metadata.authors.items.len > 0) {
        if (!first) try buf.appendSlice(allocator, ",");
        first = false;
        try buf.appendSlice(allocator, "\"authors\":[");
        for (metadata.authors.items, 0..) |author, i| {
            if (i > 0) try buf.appendSlice(allocator, ",");
            try appendAuthorJson(&buf, allocator, &author);
        }
        try buf.appendSlice(allocator, "]");
    }

    // Confidence
    if (metadata.confidence) |conf| {
        if (!first) try buf.appendSlice(allocator, ",");
        first = false;
        const conf_str = try std.fmt.allocPrint(allocator, "\"confidence\":{d:.2}", .{conf.value});
        defer allocator.free(conf_str);
        try buf.appendSlice(allocator, conf_str);
    }

    // Needs review
    if (metadata.needs_review) |nr| {
        if (!first) try buf.appendSlice(allocator, ",");
        first = false;
        try buf.appendSlice(allocator, "\"needs_review\":{");
        var nr_first = true;
        if (nr.reason) |reason| {
            try appendJsonField(&buf, allocator, "reason", reason, &nr_first);
        }
        try buf.appendSlice(allocator, "}");
    }

    // Approvals
    if (metadata.approvals.items.len > 0) {
        if (!first) try buf.appendSlice(allocator, ",");
        first = false;
        try buf.appendSlice(allocator, "\"approvals\":[");
        for (metadata.approvals.items, 0..) |approval, i| {
            if (i > 0) try buf.appendSlice(allocator, ",");
            try appendApprovalJson(&buf, allocator, &approval);
        }
        try buf.appendSlice(allocator, "]");
    }

    // Verification
    if (metadata.verification) |v| {
        if (!first) try buf.appendSlice(allocator, ",");
        first = false;
        try buf.appendSlice(allocator, "\"verification\":{");
        var v_first = true;
        try appendJsonField(&buf, allocator, "status", v.status.toString(), &v_first);
        if (v.obligations.len > 0) {
            try buf.appendSlice(allocator, ",\"obligations\":[");
            for (v.obligations, 0..) |ob, i| {
                if (i > 0) try buf.appendSlice(allocator, ",");
                try appendJsonString(&buf, allocator, ob);
            }
            try buf.appendSlice(allocator, "]");
        }
        try buf.appendSlice(allocator, "}");
    }

    // Checkpoint
    if (metadata.checkpoint) |cp| {
        if (!first) try buf.appendSlice(allocator, ",");
        first = false;
        try buf.appendSlice(allocator, "\"checkpoint\":{");
        var cp_first = true;
        try appendJsonField(&buf, allocator, "model", cp.model, &cp_first);
        if (cp.timestamp) |ts| {
            try appendJsonField(&buf, allocator, "timestamp", ts, &cp_first);
        }
        if (cp.context_hash) |ch| {
            try appendJsonField(&buf, allocator, "context_hash", ch, &cp_first);
        }
        try buf.appendSlice(allocator, "}");
    }

    // Generating
    if (metadata.generating) |g| {
        if (!first) try buf.appendSlice(allocator, ",");
        // first = false;  // Not needed - last field
        try buf.appendSlice(allocator, "\"generating\":{");
        var g_first = true;
        if (g.model) |m| {
            try appendJsonField(&buf, allocator, "model", m, &g_first);
        }
        if (g.started_at) |sa| {
            try appendJsonField(&buf, allocator, "started_at", sa, &g_first);
        }
        try buf.appendSlice(allocator, "}");
    }

    try buf.appendSlice(allocator, "}");

    return buf.toOwnedSlice(allocator);
}

fn appendJsonField(buf: *std.ArrayListUnmanaged(u8), allocator: Allocator, key: []const u8, value: []const u8, first: *bool) !void {
    if (!first.*) try buf.appendSlice(allocator, ",");
    first.* = false;
    try buf.appendSlice(allocator, "\"");
    try buf.appendSlice(allocator, key);
    try buf.appendSlice(allocator, "\":");
    try appendJsonString(buf, allocator, value);
}

fn appendJsonString(buf: *std.ArrayListUnmanaged(u8), allocator: Allocator, s: []const u8) !void {
    try buf.appendSlice(allocator, "\"");
    for (s) |c| {
        switch (c) {
            '"' => try buf.appendSlice(allocator, "\\\""),
            '\\' => try buf.appendSlice(allocator, "\\\\"),
            '\n' => try buf.appendSlice(allocator, "\\n"),
            '\r' => try buf.appendSlice(allocator, "\\r"),
            '\t' => try buf.appendSlice(allocator, "\\t"),
            else => try buf.append(allocator, c),
        }
    }
    try buf.appendSlice(allocator, "\"");
}

fn appendAuthorJson(buf: *std.ArrayListUnmanaged(u8), allocator: Allocator, author: *const Author) !void {
    try buf.appendSlice(allocator, "{");
    var first = true;
    try appendJsonField(buf, allocator, "kind", author.kind.toString(), &first);
    if (author.identity) |id| {
        try appendJsonField(buf, allocator, "identity", id, &first);
    }
    if (author.model) |m| {
        try appendJsonField(buf, allocator, "model", m, &first);
    }
    if (author.prompt_hash) |ph| {
        try appendJsonField(buf, allocator, "prompt_hash", ph, &first);
    }
    if (author.reviewed_by) |rb| {
        try appendJsonField(buf, allocator, "reviewed_by", rb, &first);
    }
    try buf.appendSlice(allocator, "}");
}

fn appendApprovalJson(buf: *std.ArrayListUnmanaged(u8), allocator: Allocator, approval: *const Approval) !void {
    try buf.appendSlice(allocator, "{");
    var first = true;
    try appendJsonField(buf, allocator, "by", approval.by, &first);
    if (approval.at) |at| {
        try appendJsonField(buf, allocator, "at", at, &first);
    }
    if (approval.note) |n| {
        try appendJsonField(buf, allocator, "note", n, &first);
    }
    try buf.appendSlice(allocator, "}");
}

// ============================================================================
// Tests
// ============================================================================

test "Author creation" {
    const human_author = Author.human("alice@example.com");
    try std.testing.expectEqual(AuthorKind.human, human_author.kind);
    try std.testing.expectEqualStrings("alice@example.com", human_author.identity.?);

    const ai_author = Author.ai("opus-4.5");
    try std.testing.expectEqual(AuthorKind.ai, ai_author.kind);
    try std.testing.expectEqualStrings("opus-4.5", ai_author.model.?);
}

test "AuthorKind fromString" {
    try std.testing.expectEqual(AuthorKind.human, AuthorKind.fromString("human").?);
    try std.testing.expectEqual(AuthorKind.ai, AuthorKind.fromString("ai").?);
    try std.testing.expectEqual(AuthorKind.mixed, AuthorKind.fromString("mixed").?);
    try std.testing.expect(AuthorKind.fromString("invalid") == null);
}

test "Confidence validation" {
    try std.testing.expect(Confidence.isValid(0.0));
    try std.testing.expect(Confidence.isValid(0.5));
    try std.testing.expect(Confidence.isValid(1.0));
    try std.testing.expect(!Confidence.isValid(-0.1));
    try std.testing.expect(!Confidence.isValid(1.1));
}

test "Confidence levels" {
    const high = Confidence.init(0.95);
    try std.testing.expectEqual(Confidence.Level.high, high.level());

    const medium = Confidence.init(0.75);
    try std.testing.expectEqual(Confidence.Level.medium, medium.level());

    const low = Confidence.init(0.55);
    try std.testing.expectEqual(Confidence.Level.low, low.level());

    const very_low = Confidence.init(0.3);
    try std.testing.expectEqual(Confidence.Level.very_low, very_low.level());
}

test "Confidence clamping" {
    const clamped_high = Confidence.init(1.5);
    try std.testing.expectEqual(@as(f64, 1.0), clamped_high.value);

    const clamped_low = Confidence.init(-0.5);
    try std.testing.expectEqual(@as(f64, 0.0), clamped_low.value);
}

test "VerifiedStatus fromString" {
    try std.testing.expectEqual(VerifiedStatus.proven, VerifiedStatus.fromString("proven").?);
    try std.testing.expectEqual(VerifiedStatus.unproven, VerifiedStatus.fromString("unproven").?);
    try std.testing.expect(VerifiedStatus.fromString("invalid") == null);
}

test "ProvenanceMetadata init/deinit" {
    const testing_alloc = std.testing.allocator;
    var metadata = ProvenanceMetadata.init(testing_alloc);
    defer metadata.deinit();

    try std.testing.expect(!metadata.isHumanAuthored());
    try std.testing.expect(!metadata.isAiGenerated());
    try std.testing.expect(!metadata.isApproved());
}

test "ProvenanceMetadata with authors" {
    const testing_alloc = std.testing.allocator;
    var metadata = ProvenanceMetadata.init(testing_alloc);
    defer metadata.deinit();

    try metadata.addAuthor(Author.human(null));
    try std.testing.expect(metadata.isHumanAuthored());
    try std.testing.expect(!metadata.isAiGenerated());
}

test "ProvenanceMetadata with approvals" {
    const testing_alloc = std.testing.allocator;
    var metadata = ProvenanceMetadata.init(testing_alloc);
    defer metadata.deinit();

    // Must allocate string since deinit will free it
    const reviewer = try testing_alloc.dupe(u8, "reviewer@example.com");
    try metadata.addApproval(.{ .by = reviewer });
    try std.testing.expect(metadata.isApproved());
}

test "ProvenanceMetadata needsReview" {
    const testing_alloc = std.testing.allocator;
    var metadata = ProvenanceMetadata.init(testing_alloc);
    defer metadata.deinit();

    try std.testing.expect(!metadata.needsReview());
    metadata.needs_review = .{ .reason = null };
    try std.testing.expect(metadata.needsReview());
}

test "ProvenanceMetadata JSON serialization" {
    const testing_alloc = std.testing.allocator;
    var metadata = ProvenanceMetadata.init(testing_alloc);
    defer metadata.deinit();

    try metadata.addAuthor(.{ .kind = .human, .identity = null });
    metadata.confidence = Confidence.init(0.85);

    const json = try toJson(testing_alloc, &metadata);
    defer testing_alloc.free(json);

    try std.testing.expect(std.mem.indexOf(u8, json, "\"authors\"") != null);
    try std.testing.expect(std.mem.indexOf(u8, json, "\"confidence\"") != null);
}
